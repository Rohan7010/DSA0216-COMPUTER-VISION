import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import cv2
import numpy as np
import matplotlib.pyplot as plt
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
class EdgeCounterCNN(nn.Module):
    def __init__(self):
        super(EdgeCounterCNN, self).__init__()

        self.features = nn.Sequential(
            nn.Conv2d(1, 16, 3, padding=1),
            nn.BatchNorm2d(16),
            nn.ReLU(),

            nn.Conv2d(16, 32, 3, padding=1),
            nn.BatchNorm2d(32),
            nn.ReLU(),

            nn.Conv2d(32, 64, 3, padding=1),
            nn.BatchNorm2d(64),
            nn.ReLU()
        )

        self.regressor = nn.Conv2d(64, 1, kernel_size=1)

    def forward(self, x):
        x = self.features(x)
        x = self.regressor(x)
        return x
def sobel_edges(image):
    sobelx = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
    sobely = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)

    magnitude = np.sqrt(sobelx**2 + sobely**2)
    magnitude = magnitude / (magnitude.max() + 1e-8)

    edge_map = (magnitude > 0.3).astype(np.float32)
    return edge_map

def edge_count_map(edge_map, window_size=16):
    edge_tensor = torch.tensor(edge_map).unsqueeze(0).unsqueeze(0)
    count_map = F.avg_pool2d(edge_tensor, kernel_size=window_size, stride=window_size)
    count_map = count_map * (window_size * window_size)
    return count_map

image = cv2.imread("input.jpg", cv2.IMREAD_GRAYSCALE)
if image is None:
    raise FileNotFoundError("Place an image named 'input.jpg' in the same directory.")

image = cv2.resize(image, (256, 256))
image = image.astype(np.float32) / 255.0

gt_edges = sobel_edges(image)
gt_counts = edge_count_map(gt_edges)

input_tensor = torch.tensor(image).unsqueeze(0).unsqueeze(0).to(device)
gt_counts = gt_counts.to(device)

model = EdgeCounterCNN().to(device)
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=1e-3)


epochs = 200

for epoch in range(epochs):
    model.train()
    optimizer.zero_grad()

    output = model(input_tensor)
    output_down = F.avg_pool2d(output, kernel_size=16, stride=16)

    loss = criterion(output_down, gt_counts)
    loss.backward()
    optimizer.step()

    if (epoch + 1) % 20 == 0:
        print(f"Epoch [{epoch+1}/{epochs}] Loss: {loss.item():.6f}")


model.eval()
with torch.no_grad():
    prediction = model(input_tensor)
    pred_down = F.avg_pool2d(prediction, kernel_size=16, stride=16)


plt.figure(figsize=(14,4))

plt.subplot(1,4,1)
plt.title("Input")
plt.imshow(image, cmap='gray')
plt.axis("off")

plt.subplot(1,4,2)
plt.title("Sobel Edge Map")
plt.imshow(gt_edges, cmap='gray')
plt.axis("off")

plt.subplot(1,4,3)
plt.title("GT Edge Counts")
plt.imshow(gt_counts.squeeze().cpu(), cmap='jet')
plt.axis("off")

plt.subplot(1,4,4)
plt.title("Predicted Counts")
plt.imshow(pred_down.squeeze().cpu(), cmap='jet')
plt.axis("off")

plt.tight_layout()
plt.show()
